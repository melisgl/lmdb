(in-package :lmdb/test)

(deftest test-env ()
  (let ((path (make-pathname :directory (list :absolute
                                              (lmdb::random-string)))))
    (signals (lmdb-error) (open-env path)))
  (with-temporary-env (env)
    (signals (lmdb-error) (open-env (env-path env)))
    (env-statistics env)
    (env-info env)))

(deftest test-open-env-nested ()
  (with-temporary-env (env)
    (signals (lmdb-error)
      (with-env (*env* (env-path env))))
    (signals (lmdb-error)
      (with-env (*env* (env-path env))))))

(deftest test-open-env-multiple-times ()
  ;; Same ENV cannot be opened twice.
  (with-temporary-env (env)
    (signals (lmdb-error) (open-env (env-path env))))
  ;; Different ENVs pointing to the same file cannot be opened twice.
  (with-temporary-env (env)
    (let ((path (merge-pathnames (env-path env) "./")))
      (signals (lmdb-error) (with-env (*env* path))))))

(deftest test-open-env-multiple-times-with-nosubdir ()
  ;; Same ENV cannot be opened twice.
  (with-temporary-env (env :subdir nil)
    (signals (lmdb-error) (open-env (env-path env))))
  ;; Different ENVs pointing to the same file cannot be opened twice.
  (with-temporary-env (env :subdir nil)
    (signals (lmdb-error)
      (with-env (*env* (env-path env) :subdir nil)))))

(deftest test-zero-map-size ()
  (with-temporary-env (*env*)
    (get-db "db")
    (close-env *env*)
    (setf (slot-value *env* 'lmdb::map-size) 0)
    (setq *env* (open-env (env-path *env*)))))

(deftest test-db ()
  (with-temporary-env (*env*)
    (get-db "db")))

(deftest test-drop-db ()
  (with-temporary-env (*env*)
    (get-db "db")
    (is (typep (get-db "db")' db))
    (signals (lmdb-error) (drop-db "db" (env-path *env*)))
    (close-env *env*)
    (drop-db "db" (env-path *env*))
    (setq *env* (open-env (env-path *env*)))
    (signals (lmdb-not-found-error :pred "Database \"db\" not found")
      (get-db "db" :if-does-not-exist :error))))

(deftest test-db-flags ()
  (loop for (option-keyword flag-value) in
        `((:integer-key ,liblmdb:+integerkey+)
          (:reverse-key ,liblmdb:+reversekey+)
          (:dupsort ,liblmdb:+dupsort+)
          (:integer-dup ,liblmdb:+integerdup+)
          (:reverse-dup ,liblmdb:+reversedup+)
          (:dupfixed ,liblmdb:+dupfixed+))
        do (with-temporary-env (*env*)
             (let ((db (get-db "db" option-keyword t)))
               (with-txn ()
                 (is (= flag-value (lmdb::db-flags db)))))
             (close-env *env*)
             (setq *env* (open-env (env-path *env*)))
             (let ((db (get-db "db" option-keyword nil)))
               (with-txn ()
                 (is (= flag-value (lmdb::db-flags db))))))))

(deftest test-close-env-in-with-txn ()
  (with-temporary-env (*env*)
    (with-txn ()
      (signals (lmdb-error
                :pred "Cannot close environment within a WITH-TXN.")
        (close-env *env*)))))

(deftest test-close-env-unsynchronized ()
  (with-temporary-env (*env* :synchronized nil)
    (with-txn ()
      (signals (lmdb-error :pred "cannot be closed explicitly")
        (close-env *env*)))
    (close-env *env* :force t)))

(deftest test-repeated-get-db ()
  (with-temporary-env (*env*)
    (with-txn ()
      (signals (lmdb-error :pred "called in an open transaction")
        (get-db "xxx")))
    (let ((db (get-db "xxx")))
      (with-txn ()
        (is (= (lmdb::%dbi (get-db "xxx"))
               (lmdb::%dbi db)))))))

(deftest test-queries ()
  (dolist (lmdb::*endianness* '(:little-endian :big-endian))
    (dolist (encoding '(nil :uint64 :octets :utf-8))
      (dolist (declare-encoding '(nil t))
        (labels ((e (x)
                   (ecase encoding
                     ((nil) (vector x))
                     ((:uint64) x)
                     ((:octets) (make-array 1 :element-type 'lmdb::octet
                                            :initial-contents (list x)))
                     ((:utf-8) (princ-to-string x))))
                 (d (x)
                   (if declare-encoding
                       (e x)
                       ;; If the encoding is not declared we get octets out.
                       (ecase encoding
                         ((nil) (vector x))
                         ((:uint64)
                          (if (eq lmdb::*endianness* :little-endian)
                              (vector x 0 0 0 0 0 0 0)
                              (vector 0 0 0 0 0 0 0 x)))
                         ((:octets)
                          (make-array 1 :element-type 'lmdb::octet
                                      :initial-contents (list x)))
                         ((:utf-8) (vector (+ (char-code #\0) x) 0))))))
          (with-temporary-env (*env* :max-dbs 2)
            (dolist (dupsort '(nil t))
              (let ((db (get-db (format nil "db~A" dupsort)
                                :dupsort dupsort
                                :key-encoding (and declare-encoding
                                                   encoding)
                                :value-encoding (and declare-encoding
                                                     encoding))))
                (with-txn ()
                  (when (not dupsort)
                    (is (= 1 (txn-id))))
                  (signals (lmdb-txn-read-only-error)
                    (put db (e 1) (e 2))))
                (with-txn (:write t)
                  (when (not dupsort)
                    (is (= 2 (txn-id))))
                  (put db (e 1) (e 2))
                  (put db (e 2) (e 3))
                  (put db (e 3) (e 4))
                  (is (equalp (get db (e 1))
                              (d 2)))
                  (is (equalp (get db (e 2))
                              (d 3)))
                  (is (equalp (get db (e 3))
                              (d 4))))
                (sync-env)
                (with-txn ()
                  (when (not dupsort)
                    (is (= 2 (txn-id))))
                  (is (equalp (get db (e 1))
                              (d 2)))
                  (is (equalp (get db (e 2))
                              (d 3)))
                  (is (equalp (get db (e 3))
                              (d 4))))
                (with-txn (:write t)
                  (signals (lmdb-key-exists-error)
                    (put db (e 1) (e 7) :overwrite nil))
                  (is (del db (e 1)))
                  (is (not (del db (e 1))))
                  (is (null (get db (e 1)))))
                (with-txn (:write t)
                  (is (null (get db (e 1))))
                  (put db (e 1) (e 2))
                  (if dupsort
                      (signals (lmdb-key-exists-error)
                        (put db (e 1) (e 2) :dupdata nil))
                      (put db (e 1) (e 2) :dupdata nil))
                  (is (equalp (get db (e 1))
                              (d 2))))))))))))

(deftest test-put ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (is (equal (multiple-value-list (put db #(1) #(2)))
                   '(t)))
        (is (equal (multiple-value-list (put db #(1) #(3)))
                   '(t)))
        (signals (lmdb-key-exists-error)
          (put db #(1) #(3) :overwrite nil))
        (is (equal (multiple-value-list (put db #(1) #(3) :overwrite nil
                                             :key-exists-error-p nil))
                   '(nil)))))))

(deftest test-put-dup ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db" :dupsort t)))
      (with-txn (:write t)
        (is (equal (multiple-value-list (put db #(1) #(2)))
                   '(t)))
        (is (equal (multiple-value-list (put db #(1) #(3)))
                   '(t)))
        (signals (lmdb-key-exists-error)
          (put db #(1) #(3) :dupdata nil))
        (is (equal (multiple-value-list (put db #(1) #(3) :dupdata nil
                                             :key-exists-error-p nil))
                   '(nil)))))))

(deftest test-encoding-override ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db" :key-encoding :uint64 :value-encoding :uint64)))
      (with-txn (:write t)
        (let ((*key-encoder* 'string-to-octets)
              (*value-encoder* :utf-8)
              (*value-decoder* 'mdb-val-to-string))
          (put db "a" "b")
          (is (equal (get db "a") "b")))))))

(deftest test-encoding-functions ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db" :key-encoding (cons #'string-to-octets
                                               #'mdb-val-to-octets)
                      :value-encoding (cons #'string-to-octets
                                            #'mdb-val-to-octets))))
      (with-txn (:write t)
        (put db "a" "b")
        (is (equalp (get db "a") #(98 0)))))))

(deftest test-closed-txn ()
  (with-temporary-env (*env* :max-dbs 2)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (abort-txn)
        (signals (lmdb-bad-txn-error)
          (get db #(1)))
        (signals (lmdb-bad-txn-error)
          (put db #(1) #(1)))
        (signals (lmdb-bad-txn-error)
          (del db #(1)))))))

(deftest test-cursor ()
  (with-temporary-env (*env* :max-dbs 2)
    (dolist (dupsort '(nil t))
      (let ((db (get-db (format nil "db~A" dupsort)
                        :dupsort dupsort)))
        (with-txn (:write t)
          ;; Empty DB
          (with-cursor (cur db)
            (if dupsort
                (signals (lmdb-cursor-uninitialized-error)
                  (cursor-count cur))
                (signals (lmdb-incompatible-error) (cursor-count cur)))
            (is (equal '(nil) (multiple-value-list
                               (cursor-set-key #(1) cur))))
            (is (equal '(nil) (multiple-value-list
                               (cursor-set-range #(1) cur))))
            (is (equal '(nil) (multiple-value-list
                               (cursor-key-value cur))))
            (is (equal '(nil) (multiple-value-list
                               (cursor-first cur))))
            (is (equal '(nil) (multiple-value-list
                               (cursor-last cur))))
            (is (equal '(nil) (multiple-value-list
                               (cursor-key-value cur))))
            (is (equal '(nil) (multiple-value-list
                               (cursor-last cur))))
            (is (equal '(nil) (multiple-value-list
                               (cursor-next cur)))))
          ;; Non-empty DB
          (put db #(1) #(2))
          (put db #(3) #(4))
          (with-cursor (cur db)
            ;; Not yet initialized
            (is (equalp '(nil) (multiple-value-list
                                (cursor-key-value cur))))
            (is (equalp '(#(1) #(2) t)
                        (multiple-value-list (cursor-first cur))))
            (is (equalp '(#(2) t)
                        (multiple-value-list (cursor-value cur))))
            (if dupsort
                (is (= 1 (cursor-count cur)))
                (signals (lmdb-incompatible-error) (cursor-count cur)))
            (is (equalp '(#(3) #(4) t)
                        (multiple-value-list (cursor-next cur))))
            (is (equalp '(nil)
                        (multiple-value-list (cursor-next cur))))
            (is (equalp '(#(1) #(2) t)
                        (multiple-value-list (cursor-prev cur))))
            (is (equalp '(nil)
                        (multiple-value-list (cursor-prev cur))))
            (is (equalp '(#(3) #(4) t)
                        (multiple-value-list (cursor-last cur))))
            (is (equalp '(#(3) #(4) t)
                        (multiple-value-list (cursor-key-value cur))))
            (is (equalp '(#(2) t)
                        (multiple-value-list
                         (cursor-set-key #(1) cur))))
            (is (equalp '(#(3) #(4) t)
                        (multiple-value-list
                         (cursor-set-range #(1 1) cur))))
            (is (equalp '(#(1) #(2) t)
                        (multiple-value-list
                         (cursor-set-range #(1) cur))))))))))

(deftest test-cursor-create ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn ()
        (commit-txn)
        (signals (lmdb-bad-txn-error)
          (with-cursor (cur db)
            (setq cur cur))))
      (with-txn ()
        (abort-txn)
        (signals (lmdb-bad-txn-error)
          (with-cursor (cur db)
            (setq cur cur))))
      (with-txn ()
        (reset-txn)
        (signals (lmdb-bad-txn-error)
          (with-cursor (cur db)
            (setq cur cur)))))))

(deftest test-cursor-dup ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db" :dupsort t)))
      (with-txn (:write t)
        (put db #(1) #(2))
        (put db #(1) #(2 1))
        (put db #(3) #(4))
        (put db #(3) #(4 1))
        (put db #(3) #(4 2))
        (with-cursor (cur db)
          ;; Not yet initialized
          (is (equalp '(nil)
                      (multiple-value-list (cursor-key-value cur))))
          (is (equalp '(#(1) #(2) t)
                      (multiple-value-list (cursor-first cur))))
          (is (equalp '(#(1) #(2) t)
                      (multiple-value-list (cursor-key-value cur))))
          (is (equalp '(#(1) #(2 1) t)
                      (multiple-value-list (cursor-next cur))))
          (is (equalp '(#(3) #(4) t)
                      (multiple-value-list (cursor-next cur))))
          (is (equalp '(#(1) #(2 1) t)
                      (multiple-value-list (cursor-prev cur))))
          (is (equalp '(#(1) #(2) t)
                      (multiple-value-list (cursor-prev cur))))
          (is (equalp '(#(3) #(4 2) t)
                      (multiple-value-list (cursor-last cur))))
          (is (equalp '(#(3) #(4 2) t)
                      (multiple-value-list (cursor-key-value cur))))
          (is (equalp '(nil)
                      (multiple-value-list
                       (cursor-set-key-dup #(1) #(7) cur))))
          (is (equal '(t)
                     (multiple-value-list
                      (cursor-set-key-dup #(1) #(2 1) cur))))
          (is (equalp '(#(1) #(2 1) t)
                      (multiple-value-list (cursor-key-value cur))))
          (is (equalp '(nil)
                      (multiple-value-list
                       (cursor-set-range-dup #(1) #(7) cur))))
          (is (equalp '(#(2 1) t)
                      (multiple-value-list
                       (cursor-set-range-dup #(1) #(2 0) cur))))
          (is (equalp '(#(3) #(4) t)
                      (multiple-value-list
                       (cursor-set-range #(1 1) cur))))
          (is (equalp '(#(1) #(2) t)
                      (multiple-value-list
                       (cursor-set-range #(1) cur)))))))))

(deftest test-cursor-put-del ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db" :dupsort t)))
      (with-txn (:write t)
        (with-cursor (cur db)
          (cursor-put #(1) #(2) cur)
          (is (= 1 (cursor-count cur)))
          (cursor-put #(1) #(2 1) cur)
          (is (= 2 (cursor-count cur)))
          (cursor-put #(1) #(2 2) cur)
          (is (= 3 (cursor-count cur)))
          (cursor-del cur)
          (is (= 2 (cursor-count cur)))
          (cursor-del cur :delete-dups t)
          (signals (lmdb-cursor-uninitialized-error)
            (= 0 (cursor-count cur))))))))

(deftest test-commit-and-cursor ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2))
        (with-cursor (cur db)
          (cursor-set-key #(1) cur)
          (is (equalp (cursor-value cur) #(2)))
          (commit-txn)
          (signals (lmdb-bad-txn-error)
            (cursor-value cur)))))))

(deftest test-iteration ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db" :dupsort t)))
      (with-txn (:write t)
        (put db #(1) #(2))
        (put db #(1) #(2 1))
        (put db #(3) #(4 2))
        (put db #(3) #(4))
        (put db #(3) #(4 1))
        ;; DO-DB
        (let ((list ()))
          (do-db (key value db)
            (push (cons key value) list))
          (is (equalp
               (reverse list)
               '((#(1) . #(2)) (#(1) . #(2 1))
                 (#(3) . #(4)) (#(3) . #(4 1)) (#(3) . #(4 2))))))
        (let ((list ()))
          (do-db (key value db :nodup t)
            (push (cons key value) list))
          (is (equalp
               (reverse list)
               '((#(1) . #(2)) (#(3) . #(4))))))
        (let ((list ()))
          (do-db (key value db :from-end t)
            (push (cons key value) list))
          (is (equalp
               list
               '((#(1) . #(2)) (#(1) . #(2 1))
                 (#(3) . #(4)) (#(3) . #(4 1)) (#(3) . #(4 2))))))
        (let ((list ()))
          (do-db (key value db :from-end t :nodup t)
            (push (cons key value) list))
          (is (equalp list '((#(1) . #(2 1)) (#(3) . #(4 2))))))
        ;; DO-DB-DUP
        (let ((list ()))
          (do-db-dup (value db #(3))
            (push value list))
          (is (equalp (reverse list)
                      '(#(4) #(4 1) #(4 2)))))
        (let ((list ()))
          (do-db-dup (value db #(3) :from-end t)
            (push value list))
          (is (equalp list '(#(4) #(4 1) #(4 2)))))
        ;; DO-CURSOR
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor (key value cursor)
              (push (cons key value) list))
            (is (equalp (reverse list)
                        '((#(3) . #(4 1)) (#(3) . #(4 2)))))))
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor (key value cursor :nodup t)
              (push (cons key value) list))
            (is (equalp (reverse list)
                        '((#(3) . #(4 1)))))))
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor (key value cursor :from-end t)
              (push (cons key value) list))
            (is (equalp (reverse list)
                        '((#(3) . #(4 1)) (#(3) . #(4))
                          (#(1) . #(2 1)) (#(1) . #(2)))))))
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor (key value cursor :from-end t :nodup t)
              (push (cons key value) list))
            (is (equalp (reverse list)
                        '((#(3) . #(4 1)) (#(1) . #(2 1)))))))
        ;; DO-CURSOR-DUP
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor-dup (value cursor)
              (push value list))
            (is (equalp (reverse list)
                        '(#(4 1) #(4 2))))))
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor-dup (value cursor :from-end t)
              (push value list))
            (is (equalp (reverse list)
                        '(#(4 1) #(4))))))))))

(deftest test-iteration-with-null-values ()
  (let ((null-encoding (cons #'identity (constantly nil))))
    (with-temporary-env (*env*)
      (let ((db (get-db "db" :dupsort t
                        :value-encoding null-encoding)))
        (with-txn (:write t)
          (put db #(1) #(2))
          (put db #(1) #(2 1))
          (put db #(3) #(4 2))
          (put db #(3) #(4))
          (put db #(3) #(4 1))
          ;; DO-DB
          (let ((list ()))
            (do-db (key value db)
              (push (cons key value) list))
            (is (equalp
                 (reverse list)
                 '((#(1) . nil) (#(1) . nil)
                   (#(3) . nil) (#(3) . nil) (#(3) . nil)))))
          (let ((list ()))
            (do-db (key value db :nodup t)
              (push (cons key value) list))
            (is (equalp
                 (reverse list)
                 '((#(1) . nil) (#(3) . nil)))))
          (let ((list ()))
            (do-db (key value db :from-end t)
              (push (cons key value) list))
            (is (equalp
                 list
                 '((#(1) . nil) (#(1) . nil)
                   (#(3) . nil) (#(3) . nil) (#(3) . nil)))))
          (let ((list ()))
            (do-db (key value db :from-end t :nodup t)
              (push (cons key value) list))
            (is (equalp list '((#(1) . nil) (#(3) . nil)))))
          ;; DO-DB-DUP
          (let ((list ()))
            (do-db-dup (value db #(3))
              (push value list))
            (is (equalp (reverse list)
                        '(nil nil nil))))
          (let ((list ()))
            (do-db-dup (value db #(3) :from-end t)
              (push value list))
            (is (equalp list '(nil nil nil))))
          ;; DO-CURSOR
          (with-cursor (cursor db)
            (cursor-set-key-dup #(3) #(4 1) cursor)
            (let ((list ()))
              (do-cursor (key value cursor)
                (push (cons key value) list))
              (is (equalp (reverse list)
                          '((#(3) . nil) (#(3) . nil))))))
          (with-cursor (cursor db)
            (cursor-set-key-dup #(3) #(4 1) cursor)
            (let ((list ()))
              (do-cursor (key value cursor :nodup t)
                (push (cons key value) list))
              (is (equalp (reverse list)
                          '((#(3) . nil))))))
          (with-cursor (cursor db)
            (cursor-set-key-dup #(3) #(4 1) cursor)
            (let ((list ()))
              (do-cursor (key value cursor :from-end t)
                (push (cons key value) list))
              (is (equalp (reverse list)
                          '((#(3) . nil) (#(3) . nil)
                            (#(1) . nil) (#(1) . nil))))))
          (with-cursor (cursor db)
            (cursor-set-key-dup #(3) #(4 1) cursor)
            (let ((list ()))
              (do-cursor (key value cursor :from-end t :nodup t)
                (push (cons key value) list))
              (is (equalp (reverse list)
                          '((#(3) . nil) (#(1) . nil))))))
          ;; DO-CURSOR-DUP
          (with-cursor (cursor db)
            (cursor-set-key-dup #(3) #(4 1) cursor)
            (let ((list ()))
              (do-cursor-dup (value cursor)
                (push value list))
              (is (equalp (reverse list)
                          '(nil nil)))))
          (with-cursor (cursor db)
            (cursor-set-key-dup #(3) #(4 1) cursor)
            (let ((list ()))
              (do-cursor-dup (value cursor :from-end t)
                (push value list))
              (is (equalp (reverse list)
                          '(nil nil))))))))))

(deftest test-renew-txn ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2))
        (put db #(3) #(4))
        (signals (lmdb-error) (reset-txn))
        (signals (lmdb-error) (renew-txn)))
      (with-txn ()
        (is (equalp (get db #(1)) #(2)))
        (is (open-txn-p))
        (reset-txn)
        (is (not (open-txn-p)))
        (renew-txn)
        (is (open-txn-p))
        (is (equalp (get db #(1)) #(2)))
        (is (equalp (get db #(3)) #(4)))))))

(deftest test-nested-txn ()
  (with-temporary-env (*env*)
    (let ((db (get-db (format nil "db"))))
      (with-txn (:write t)
        (is (null (get db #(1))))
        (put db #(5) #(6))
        (with-txn (:write t)
          (is (equalp (get db #(5)) #(6)))
          (put db #(1) #(2))
          (put db #(3) #(4)))
        (is (equalp (get db #(1)) #(2)))
        (is (equalp (get db #(3)) #(4)))
        (with-txn (:write t)
          (put db #(1) #(20))
          (put db #(3) #(40))
          (abort-txn))
        (is (equalp (get db #(1)) #(2)))
        (is (equalp (get db #(3)) #(4))))
      ;; Nesting read-only transactions nets EINVAL, but we turn some
      ;; of that into noops.
      (with-txn ()
        (with-txn ()))
      (with-txn ()
        (signals (lmdb-error)
          (with-txn (:write t))))
      (with-txn (:write t)
        (with-txn ())))))

(deftest test-nested-txn-with-different-env ()
  (with-temporary-env (env)
    (with-txn (:env env :write t)
      (with-temporary-env (*env*)
        (let ((db (get-db "db")))
          (with-txn (:write t)
            (is (null (get db #(1))))
            (put db #(5) #(6))
            (with-txn (:write t)
              (is (equalp (get db #(5)) #(6)))
              (put db #(1) #(2))
              (put db #(3) #(4)))
            (is (equalp (get db #(1)) #(2)))
            (is (equalp (get db #(3)) #(4)))
            (with-txn (:write t)
              (put db #(1) #(20))
              (put db #(3) #(40))
              (abort-txn))
            (is (equalp (get db #(1)) #(2)))
            (is (equalp (get db #(3)) #(4))))
          ;; Nesting read-only transactions nets EINVAL, but we turn some
          ;; of that into noops.
          (with-txn ()
            (with-txn ()))
          (with-txn ()
            (signals (lmdb-error)
              (with-txn (:write t))))
          (with-txn (:write t)
            (with-txn ())))))))

(deftest test-ignore-parent ()
  (dolist (tls '(t nil))
    (with-temporary-env (*env* :tls tls)
      ;; This creates a second read transaction and is thus an error with TLS.
      (with-txn ()
        (if tls
            (signals (lmdb-bad-rslot-error)
              (with-txn (:ignore-parent t)))
            (with-txn (:ignore-parent t))))
      ;; Two write transactions like this would deadlock, but we
      ;; detect this on the Lisp side.
      (with-txn (:write t)
        (signals (lmdb-bad-txn-error)
          (with-txn (:write t :ignore-parent t))))
      ;; However, having a read and write transaction is possible.
      (with-txn (:write t)
        (with-txn (:ignore-parent t)))
      ;; The order of creation doesn't matter.
      (with-txn ()
        (with-txn (:write t :ignore-parent t))))))

(deftest test-commit-and-renew-cursor ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2)))
      (with-txn ()
        (with-cursor (cur db)
          (cursor-set-key #(1) cur)
          (is (equalp (cursor-value cur) #(2)))
          (commit-txn)
          (signals (lmdb-bad-txn-error)
            (cursor-value cur))
          (signals (lmdb-error)
            (cursor-renew cur))
          (with-txn ()
            (cursor-renew cur)
            (is (equalp (cursor-set-key #(1) cur) #(2)))))))))

(deftest test-abort-and-renew-cursor ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2)))
      (with-txn ()
        (with-cursor (cur db)
          (cursor-set-key #(1) cur)
          (is (equalp (cursor-value cur) #(2)))
          (abort-txn)
          (signals (lmdb-bad-txn-error)
            (cursor-value cur))
          (signals (lmdb-error)
            (cursor-renew cur))
          (with-txn ()
            (cursor-renew cur)
            (is (equalp (cursor-set-key #(1) cur) #(2)))))))))

(deftest test-reset-and-renew-cursor ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2)))
      (with-txn ()
        (with-cursor (cur db)
          (cursor-set-key #(1) cur)
          (is (equalp (cursor-value cur) #(2)))
          (reset-txn)
          (signals (lmdb-bad-txn-error)
            (cursor-value cur))
          (signals (lmdb-error)
            (cursor-renew cur))
          (renew-txn)
          (cursor-renew cur)
          (is (equalp (cursor-set-key #(1) cur) #(2))))))))

(deftest test-parent-illegal-op ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(1))
        (with-cursor (cursor db)
          (with-txn (:write t)
            (signals (lmdb-illegal-access-to-parent-txn-error)
              (cursor-set-key #(1) cursor))))
        (with-cursor (cursor db)
          (with-temporary-env (env)
            (with-txn (:write t :env env)
              (cursor-set-key #(1) cursor))))))))

(deftest test-cursor-txn-reuse ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(1)))
      (with-txn ()
        (with-cursor (cursor db)
          (abort-txn)
          (with-txn ()
            (signals (lmdb-bad-txn-error)
              (cursor-set-key #(1) cursor))))))))

(deftest test-all ()
  (test-env)
  (test-open-env-nested)
  (test-open-env-multiple-times)
  (test-open-env-multiple-times-with-nosubdir)
  (test-zero-map-size)
  (test-db)
  (test-drop-db)
  (test-db-flags)
  (test-close-env-in-with-txn)
  (test-close-env-unsynchronized)
  (test-repeated-get-db)
  (test-queries)
  (test-put)
  (test-put-dup)
  (test-encoding-override)
  (test-encoding-functions)
  (test-closed-txn)
  (test-cursor)
  (test-cursor-create)
  (test-cursor-dup)
  (test-cursor-put-del)
  (test-commit-and-cursor)
  (test-iteration)
  (test-iteration-with-null-values)
  (test-renew-txn)
  (test-nested-txn)
  (test-nested-txn-with-different-env)
  (test-ignore-parent)
  (test-commit-and-renew-cursor)
  (test-abort-and-renew-cursor)
  (test-reset-and-renew-cursor)
  (test-parent-illegal-op)
  (test-cursor-txn-reuse))

(defun test (&key (debug nil) (print 'unexpected) (describe 'unexpected))
  ;; Bind *PACKAGE* so that names of tests printed have package names,
  ;; and M-. works on them in Slime.
  (let ((*package* (find-package :common-lisp))
        (*print-duration* nil)
        (*print-compactly* nil)
        (*defer-describe* nil))
    (warn-on-tests-not-run ((find-package :lmdb-test))
      (print (try 'test-all :debug debug :print print :describe describe)))))

#+nil
(test)

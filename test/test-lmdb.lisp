(in-package :lmdb/test)

(defmacro assert-error ((condition-type &optional substring) &body body)
  (alexandria:once-only (substring)
    (alexandria:with-gensyms (got-it c)
      `(let ((,got-it nil))
         (unwind-protect
              (handler-case (progn ,@body)
                (,condition-type (,c)
                  (if (or (null ,substring)
                          (search ,substring
                                  (with-standard-io-syntax
                                    (princ-to-string ,c))))
                      (setq ,got-it t)
                      (setq ,got-it ,c))))
           (assert (eq ,got-it t) ()
                   "~@<Didn't get expected ~S containing ~S. Got a ~S ~
                    saying ~S.~:@>"
                   ',condition-type ,substring (type-of ,got-it)
                   (with-standard-io-syntax
                     (princ-to-string ,got-it))))))))

(defun test-env ()
  (let ((path (make-pathname :directory (list :absolute
                                              (lmdb::random-string)))))
    (assert-error (lmdb-error) (open-env path)))
  (with-temporary-env (env)
    (assert-error (lmdb-error) (open-env (env-path env)))
    (env-statistics env)
    (env-info env)))

(defun test-open-env-nested ()
  (with-temporary-env (env)
    (assert-error (lmdb-error)
      (with-env (*env* (env-path env))))
    (assert-error (lmdb-error)
      (with-env (*env* (env-path env))))))

(defun test-open-env-multiple-times ()
  ;; Same ENV cannot be opened twice.
  (with-temporary-env (env)
    (assert-error (lmdb-error) (open-env (env-path env))))
  ;; Different ENVs pointing to the same file cannot be opened twice.
  (with-temporary-env (env)
    (let ((path (merge-pathnames (env-path env) "./")))
      (assert-error (lmdb-error) (with-env (*env* path))))))

(defun test-open-env-multiple-times-with-nosubdir ()
  ;; Same ENV cannot be opened twice.
  (with-temporary-env (env :subdir nil)
    (assert-error (lmdb-error) (open-env (env-path env))))
  ;; Different ENVs pointing to the same file cannot be opened twice.
  (with-temporary-env (env :subdir nil)
    (assert-error (lmdb-error)
      (with-env (*env* (env-path env) :subdir nil)))))

(defun test-zero-map-size ()
  (with-temporary-env (*env*)
    (get-db "db")
    (close-env *env*)
    (setf (slot-value *env* 'lmdb::map-size) 0)
    (setq *env* (open-env (env-path *env*)))))

(defun test-db ()
  (with-temporary-env (*env*)
    (get-db "db")))

(defun test-drop-db ()
  (with-temporary-env (*env*)
    (get-db "db")
    (assert (typep (get-db "db")' db))
    (assert-error (lmdb-error) (drop-db "db" (env-path *env*)))
    (close-env *env*)
    (drop-db "db" (env-path *env*))
    (setq *env* (open-env (env-path *env*)))
    (assert-error (lmdb-not-found-error "Database \"db\" not found")
      (get-db "db" :if-does-not-exist :error))))

(defun test-db-flags ()
  (loop for (option-keyword flag-value) in
        `((:integer-key ,liblmdb:+integerkey+)
          (:reverse-key ,liblmdb:+reversekey+)
          (:dupsort ,liblmdb:+dupsort+)
          (:integer-dup ,liblmdb:+integerdup+)
          (:reverse-dup ,liblmdb:+reversedup+)
          (:dupfixed ,liblmdb:+dupfixed+))
        do (with-temporary-env (*env*)
             (let ((db (get-db "db" option-keyword t)))
               (with-txn ()
                 (assert (= flag-value (lmdb::db-flags db)))))
             (close-env *env*)
             (setq *env* (open-env (env-path *env*)))
             (let ((db (get-db "db" option-keyword nil)))
               (with-txn ()
                 (assert (= flag-value (lmdb::db-flags db))))))))

(defun test-close-env-in-with-txn ()
  (with-temporary-env (*env*)
    (with-txn ()
      (assert-error (lmdb-error "Cannot close environment within a WITH-TXN.")
        (close-env *env*)))))

(defun test-close-env-unsynchronized ()
  (with-temporary-env (*env* :synchronized nil)
    (with-txn ()
      (assert-error (lmdb-error "cannot be closed explicitly")
        (close-env *env*)))
    (close-env *env* :force t)))

(defun test-queries ()
  (dolist (lmdb::*endianness* '(:little-endian :big-endian))
    (dolist (encoding '(nil :uint64 :octets :utf-8))
      (dolist (declare-encoding '(nil t))
        (labels ((e (x)
                   (ecase encoding
                     ((nil) (vector x))
                     ((:uint64) x)
                     ((:octets) (make-array 1 :element-type 'lmdb::octet
                                            :initial-contents (list x)))
                     ((:utf-8) (princ-to-string x))))
                 (d (x)
                   (if declare-encoding
                       (e x)
                       ;; If the encoding is not declared we get octets out.
                       (ecase encoding
                         ((nil) (vector x))
                         ((:uint64)
                          (if (eq lmdb::*endianness* :little-endian)
                              (vector x 0 0 0 0 0 0 0)
                              (vector 0 0 0 0 0 0 0 x)))
                         ((:octets)
                          (make-array 1 :element-type 'lmdb::octet
                                      :initial-contents (list x)))
                         ((:utf-8) (vector (+ (char-code #\0) x) 0))))))
          (with-temporary-env (*env* :max-dbs 2)
            (dolist (dupsort '(nil t))
              (let ((db (get-db (format nil "db~A" dupsort)
                                :dupsort dupsort
                                :key-encoding (and declare-encoding
                                                   encoding)
                                :value-encoding (and declare-encoding
                                                     encoding))))
                (with-txn ()
                  (when (not dupsort)
                    (assert (= 1 (txn-id))))
                  (assert-error (lmdb-txn-read-only-error)
                    (put db (e 1) (e 2))))
                (with-txn (:write t)
                  (when (not dupsort)
                    (assert (= 2 (txn-id))))
                  (put db (e 1) (e 2))
                  (put db (e 2) (e 3))
                  (put db (e 3) (e 4))
                  (assert (equalp (g3t db (e 1))
                                  (d 2)))
                  (assert (equalp (g3t db (e 2))
                                  (d 3)))
                  (assert (equalp (g3t db (e 3))
                                  (d 4))))
                (sync-env)
                (with-txn ()
                  (when (not dupsort)
                    (assert (= 2 (txn-id))))
                  (assert (equalp (g3t db (e 1))
                                  (d 2)))
                  (assert (equalp (g3t db (e 2))
                                  (d 3)))
                  (assert (equalp (g3t db (e 3))
                                  (d 4))))
                (with-txn (:write t)
                  (assert-error (lmdb-key-exists-error)
                    (put db (e 1) (e 7) :overwrite nil))
                  (assert (del db (e 1)))
                  (assert (not (del db (e 1))))
                  (assert (null (g3t db (e 1)))))
                (with-txn (:write t)
                  (assert (null (g3t db (e 1))))
                  (put db (e 1) (e 2))
                  (if dupsort
                      (assert-error (lmdb-key-exists-error)
                        (put db (e 1) (e 2) :dupdata nil))
                      (put db (e 1) (e 2) :dupdata nil))
                  (assert (equalp (g3t db (e 1))
                                  (d 2))))))))))))

(defun test-closed-txn ()
  (with-temporary-env (*env* :max-dbs 2)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (abort-txn)
        (assert-error (lmdb-bad-txn-error)
          (g3t db #(1)))
        (assert-error (lmdb-bad-txn-error)
          (put db #(1) #(1)))
        (assert-error (lmdb-bad-txn-error)
          (del db #(1)))))))

(defun test-cursor ()
  (with-temporary-env (*env* :max-dbs 2)
    (dolist (dupsort '(nil t))
      (let ((db (get-db (format nil "db~A" dupsort)
                        :dupsort dupsort)))
        (with-txn (:write t)
          ;; Empty DB
          (with-cursor (cur db)
            (if dupsort
                (assert-error (lmdb-cursor-uninitialized-error)
                  (cursor-count cur))
                (assert-error (lmdb-incompatible-error) (cursor-count cur)))
            (assert (equal '(nil) (multiple-value-list
                                   (cursor-set-key #(1) cur))))
            (assert (equal '(nil) (multiple-value-list
                                   (cursor-set-range #(1) cur))))
            (assert (equal '(nil) (multiple-value-list
                                   (cursor-key-value cur))))
            (assert (equal '(nil) (multiple-value-list
                                   (cursor-first cur))))
            (assert (equal '(nil) (multiple-value-list
                                   (cursor-last cur))))
            (assert (equal '(nil) (multiple-value-list
                                   (cursor-key-value cur))))
            (assert (equal '(nil) (multiple-value-list
                                   (cursor-last cur))))
            (assert (equal '(nil) (multiple-value-list
                                   (cursor-next cur)))))
          ;; Non-empty DB
          (put db #(1) #(2))
          (put db #(3) #(4))
          (with-cursor (cur db)
            ;; Not yet initialized
            (assert (equalp '(nil) (multiple-value-list
                                    (cursor-key-value cur))))
            (assert (equalp '(#(1) #(2) t)
                            (multiple-value-list (cursor-first cur))))
            (assert (equalp '(#(2) t)
                            (multiple-value-list (cursor-value cur))))
            (if dupsort
                (assert (= 1 (cursor-count cur)))
                (assert-error (lmdb-incompatible-error) (cursor-count cur)))
            (assert (equalp '(#(3) #(4) t)
                            (multiple-value-list (cursor-next cur))))
            (assert (equalp '(nil)
                            (multiple-value-list (cursor-next cur))))
            (assert (equalp '(#(1) #(2) t)
                            (multiple-value-list (cursor-prev cur))))
            (assert (equalp '(nil)
                            (multiple-value-list (cursor-prev cur))))
            (assert (equalp '(#(3) #(4) t)
                            (multiple-value-list (cursor-last cur))))
            (assert (equalp '(#(3) #(4) t)
                            (multiple-value-list (cursor-key-value cur))))
            (assert (equalp '(#(2) t)
                            (multiple-value-list
                             (cursor-set-key #(1) cur))))
            (assert (equalp '(#(3) #(4) t)
                            (multiple-value-list
                             (cursor-set-range #(1 1) cur))))
            (assert (equalp '(#(1) #(2) t)
                            (multiple-value-list
                             (cursor-set-range #(1) cur))))))))))

(defun test-cursor-create ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn ()
        (commit-txn)
        (assert-error (lmdb-bad-txn-error)
          (with-cursor (cur db)
            (setq cur cur))))
      (with-txn ()
        (abort-txn)
        (assert-error (lmdb-bad-txn-error)
          (with-cursor (cur db)
            (setq cur cur))))
      (with-txn ()
        (reset-txn)
        (assert-error (lmdb-bad-txn-error)
          (with-cursor (cur db)
            (setq cur cur)))))))

(defun test-cursor-dup ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db" :dupsort t)))
      (with-txn (:write t)
        (put db #(1) #(2))
        (put db #(1) #(2 1))
        (put db #(3) #(4))
        (put db #(3) #(4 1))
        (put db #(3) #(4 2))
        (with-cursor (cur db)
          ;; Not yet initialized
          (assert (equalp '(nil)
                          (multiple-value-list (cursor-key-value cur))))
          (assert (equalp '(#(1) #(2) t)
                          (multiple-value-list (cursor-first cur))))
          (assert (equalp '(#(1) #(2) t)
                          (multiple-value-list (cursor-key-value cur))))
          (assert (equalp '(#(1) #(2 1) t)
                          (multiple-value-list (cursor-next cur))))
          (assert (equalp '(#(3) #(4) t)
                          (multiple-value-list (cursor-next cur))))
          (assert (equalp '(#(1) #(2 1) t)
                          (multiple-value-list (cursor-prev cur))))
          (assert (equalp '(#(1) #(2) t)
                          (multiple-value-list (cursor-prev cur))))
          (assert (equalp '(#(3) #(4 2) t)
                          (multiple-value-list (cursor-last cur))))
          (assert (equalp '(#(3) #(4 2) t)
                          (multiple-value-list (cursor-key-value cur))))
          (assert (equalp '(nil)
                          (multiple-value-list
                           (cursor-set-key-dup #(1) #(7) cur))))
          (assert (equal '(t)
                         (multiple-value-list
                          (cursor-set-key-dup #(1) #(2 1) cur))))
          (assert (equalp '(#(1) #(2 1) t)
                          (multiple-value-list (cursor-key-value cur))))
          (assert (equalp '(nil)
                          (multiple-value-list
                           (cursor-set-range-dup #(1) #(7) cur))))
          (assert (equalp '(#(2 1) t)
                          (multiple-value-list
                           (cursor-set-range-dup #(1) #(2 0) cur))))
          (assert (equalp '(#(3) #(4) t)
                          (multiple-value-list
                           (cursor-set-range #(1 1) cur))))
          (assert (equalp '(#(1) #(2) t)
                          (multiple-value-list
                           (cursor-set-range #(1) cur)))))))))

(defun test-cursor-put-del ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db" :dupsort t)))
      (with-txn (:write t)
        (with-cursor (cur db)
          (cursor-put #(1) #(2) cur)
          (assert (= 1 (cursor-count cur)))
          (cursor-put #(1) #(2 1) cur)
          (assert (= 2 (cursor-count cur)))
          (cursor-put #(1) #(2 2) cur)
          (assert (= 3 (cursor-count cur)))
          (cursor-del cur)
          (assert (= 2 (cursor-count cur)))
          (cursor-del cur :delete-dups t)
          (assert-error (lmdb-cursor-uninitialized-error)
            (= 0 (cursor-count cur))))))))

(defun test-commit-and-cursor ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2))
        (with-cursor (cur db)
          (cursor-set-key #(1) cur)
          (assert (equalp (cursor-value cur) #(2)))
          (commit-txn)
          (assert-error (lmdb-bad-txn-error)
            (cursor-value cur)))))))

(defun test-iteration ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db" :dupsort t)))
      (with-txn (:write t)
        (put db #(1) #(2))
        (put db #(1) #(2 1))
        (put db #(3) #(4 2))
        (put db #(3) #(4))
        (put db #(3) #(4 1))
        ;; DO-DB
        (let ((list ()))
          (do-db (key value db)
            (push (cons key value) list))
          (assert (equalp
                   (reverse list)
                   '((#(1) . #(2)) (#(1) . #(2 1))
                     (#(3) . #(4)) (#(3) . #(4 1)) (#(3) . #(4 2))))))
        (let ((list ()))
          (do-db (key value db :nodup t)
            (push (cons key value) list))
          (assert (equalp
                   (reverse list)
                   '((#(1) . #(2)) (#(3) . #(4))))))
        (let ((list ()))
          (do-db (key value db :from-end t)
            (push (cons key value) list))
          (assert (equalp
                   list
                   '((#(1) . #(2)) (#(1) . #(2 1))
                     (#(3) . #(4)) (#(3) . #(4 1)) (#(3) . #(4 2))))))
        (let ((list ()))
          (do-db (key value db :from-end t :nodup t)
            (push (cons key value) list))
          (assert (equalp list '((#(1) . #(2 1)) (#(3) . #(4 2))))))
        ;; DO-DB-DUP
        (let ((list ()))
          (do-db-dup (value db #(3))
            (push value list))
          (assert (equalp (reverse list)
                          '(#(4) #(4 1) #(4 2)))))
        (let ((list ()))
          (do-db-dup (value db #(3) :from-end t)
            (push value list))
          (assert (equalp list '(#(4) #(4 1) #(4 2)))))
        ;; DO-CURSOR
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor (key value cursor)
              (push (cons key value) list))
            (assert (equalp (reverse list)
                            '((#(3) . #(4 1)) (#(3) . #(4 2)))))))
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor (key value cursor :nodup t)
              (push (cons key value) list))
            (assert (equalp (reverse list)
                            '((#(3) . #(4 1)))))))
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor (key value cursor :from-end t)
              (push (cons key value) list))
            (assert (equalp (reverse list)
                            '((#(3) . #(4 1)) (#(3) . #(4))
                              (#(1) . #(2 1)) (#(1) . #(2)))))))
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor (key value cursor :from-end t :nodup t)
              (push (cons key value) list))
            (assert (equalp (reverse list)
                            '((#(3) . #(4 1)) (#(1) . #(2 1)))))))
        ;; DO-CURSOR-DUP
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor-dup (value cursor)
              (push value list))
            (assert (equalp (reverse list)
                            '(#(4 1) #(4 2))))))
        (with-cursor (cursor db)
          (cursor-set-key-dup #(3) #(4 1) cursor)
          (let ((list ()))
            (do-cursor-dup (value cursor :from-end t)
              (push value list))
            (assert (equalp (reverse list)
                            '(#(4 1) #(4))))))))))

(defun test-renew-txn ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2))
        (put db #(3) #(4))
        (assert-error (lmdb-error) (reset-txn))
        (assert-error (lmdb-error) (renew-txn)))
      (with-txn ()
        (assert (equalp (g3t db #(1)) #(2)))
        (assert (open-txn-p))
        (reset-txn)
        (assert (not (open-txn-p)))
        (renew-txn)
        (assert (open-txn-p))
        (assert (equalp (g3t db #(1)) #(2)))
        (assert (equalp (g3t db #(3)) #(4)))))))

(defun test-nested-txn ()
  (with-temporary-env (*env*)
    (let ((db (get-db (format nil "db"))))
      (with-txn (:write t)
        (assert (null (g3t db #(1))))
        (put db #(5) #(6))
        (with-txn (:write t)
          (assert (equalp (g3t db #(5)) #(6)))
          (put db #(1) #(2))
          (put db #(3) #(4)))
        (assert (equalp (g3t db #(1)) #(2)))
        (assert (equalp (g3t db #(3)) #(4)))
        (with-txn (:write t)
          (put db #(1) #(20))
          (put db #(3) #(40))
          (abort-txn))
        (assert (equalp (g3t db #(1)) #(2)))
        (assert (equalp (g3t db #(3)) #(4))))
      ;; Nesting read-only transactions nets EINVAL, but we turn some
      ;; of that into noops.
      (with-txn ()
        (with-txn ()))
      (with-txn ()
        (assert-error (lmdb-error)
          (with-txn (:write t))))
      (with-txn (:write t)
        (with-txn ())))))

(defun test-nested-txn-with-different-env ()
  (with-temporary-env (env)
    (with-txn (:env env :write t)
      (with-temporary-env (*env*)
        (let ((db (get-db "db")))
          (with-txn (:write t)
            (assert (null (g3t db #(1))))
            (put db #(5) #(6))
            (with-txn (:write t)
              (assert (equalp (g3t db #(5)) #(6)))
              (put db #(1) #(2))
              (put db #(3) #(4)))
            (assert (equalp (g3t db #(1)) #(2)))
            (assert (equalp (g3t db #(3)) #(4)))
            (with-txn (:write t)
              (put db #(1) #(20))
              (put db #(3) #(40))
              (abort-txn))
            (assert (equalp (g3t db #(1)) #(2)))
            (assert (equalp (g3t db #(3)) #(4))))
          ;; Nesting read-only transactions nets EINVAL, but we turn some
          ;; of that into noops.
          (with-txn ()
            (with-txn ()))
          (with-txn ()
            (assert-error (lmdb-error)
              (with-txn (:write t))))
          (with-txn (:write t)
            (with-txn ())))))))

(defun test-ignore-parent ()
  (dolist (tls '(t nil))
    (with-temporary-env (*env* :tls tls)
      ;; This creates a second read transaction and is thus an error with TLS.
      (with-txn ()
        (if tls
            (assert-error (lmdb-bad-rslot-error)
              (with-txn (:ignore-parent t)))
            (with-txn (:ignore-parent t))))
      ;; Two write transactions like this would deadlock, but we
      ;; detect this on the Lisp side.
      (with-txn (:write t)
        (assert-error (lmdb-bad-txn-error)
          (with-txn (:write t :ignore-parent t))))
      ;; However, having a read and write transaction is possible.
      (with-txn (:write t)
        (with-txn (:ignore-parent t)))
      ;; The order of creation doesn't matter.
      (with-txn ()
        (with-txn (:write t :ignore-parent t))))))

(defun test-commit-and-renew-cursor ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2)))
      (with-txn ()
        (with-cursor (cur db)
          (cursor-set-key #(1) cur)
          (assert (equalp (cursor-value cur) #(2)))
          (commit-txn)
          (assert-error (lmdb-bad-txn-error)
            (cursor-value cur))
          (assert-error (lmdb-error)
            (cursor-renew cur))
          (with-txn ()
            (cursor-renew cur)
            (assert (equalp (cursor-set-key #(1) cur) #(2)))))))))

(defun test-abort-and-renew-cursor ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2)))
      (with-txn ()
        (with-cursor (cur db)
          (cursor-set-key #(1) cur)
          (assert (equalp (cursor-value cur) #(2)))
          (abort-txn)
          (assert-error (lmdb-bad-txn-error)
            (cursor-value cur))
          (assert-error (lmdb-error)
            (cursor-renew cur))
          (with-txn ()
            (cursor-renew cur)
            (assert (equalp (cursor-set-key #(1) cur) #(2)))))))))

(defun test-reset-and-renew-cursor ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(2)))
      (with-txn ()
        (with-cursor (cur db)
          (cursor-set-key #(1) cur)
          (assert (equalp (cursor-value cur) #(2)))
          (reset-txn)
          (assert-error (lmdb-bad-txn-error)
            (cursor-value cur))
          (assert-error (lmdb-error)
            (cursor-renew cur))
          (renew-txn)
          (cursor-renew cur)
          (assert (equalp (cursor-set-key #(1) cur) #(2))))))))

(defun test-parent-illegal-op ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(1))
        (with-cursor (cursor db)
          (with-txn (:write t)
            (assert-error (lmdb-illegal-access-to-parent-txn-error)
              (cursor-set-key #(1) cursor))))
        (with-cursor (cursor db)
          (with-temporary-env (env)
            (with-txn (:write t :env env)
              (cursor-set-key #(1) cursor))))))))

(defun test-cursor-txn-reuse ()
  (with-temporary-env (*env*)
    (let ((db (get-db "db")))
      (with-txn (:write t)
        (put db #(1) #(1)))
      (with-txn ()
        (with-cursor (cursor db)
          (abort-txn)
          (with-txn ()
            (assert-error (lmdb-bad-txn-error)
              (cursor-set-key #(1) cursor))))))))

(defun test ()
  (test-env)
  (test-open-env-nested)
  (test-open-env-multiple-times)
  (test-open-env-multiple-times-with-nosubdir)
  (test-zero-map-size)
  (test-db)
  (test-drop-db)
  (test-db-flags)
  (test-close-env-in-with-txn)
  (test-close-env-unsynchronized)
  (test-queries)
  (test-closed-txn)
  (test-cursor)
  (test-cursor-create)
  (test-cursor-dup)
  (test-cursor-put-del)
  (test-commit-and-cursor)
  (test-iteration)
  (test-renew-txn)
  (test-nested-txn)
  (test-nested-txn-with-different-env)
  (test-ignore-parent)
  (test-commit-and-renew-cursor)
  (test-abort-and-renew-cursor)
  (test-reset-and-renew-cursor)
  (test-parent-illegal-op)
  (test-cursor-txn-reuse))

#+nil
(time (test))
